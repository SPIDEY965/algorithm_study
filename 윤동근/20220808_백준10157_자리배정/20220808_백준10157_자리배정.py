x,y= map(int,input().split()) #극장 x너비, y너비 입력
n=int(input()) #몇번쨰 티켓팅인지 입력.
def check(n,x,y):#n번째 티켓팅한 사람이 몇번째 칸에 앉을지 출력하는 함수
    if n>x*y: #n이 좌석갯수보다 늦게 티켓팅해서 앉을자리가 없으면 0 출력
        return print(0)
    m=min(x,y) #m은 x,y 너비중 더 작은 것을 반환. 시계방향으로 최소 몇사이클까지 돌아갈 수 있는지 알 수 있다.
    #예를 들면 작은 값이 3이면, 시계방향으로 돌렸을떄 1바퀴하고 약간 더 돌수 있다. 3//2=1 -> 1바퀴에서 2바퀴 사이 돌면 끝이다. 2//2=1 ->1바퀴 돌고 끝이다.
    order=0 #x,y의 범위는 최소 5이상이다. 따라서 최소 2바퀴 이상 돌 수 있으며, 가장 바깥쪽은 1바퀴에 x+y*2-4개의 자리가 쓰이고,
    #그다음 안쪽 1바퀴는 x+y*2-4개의 자리에 (x+y-4*1)*2-4개의 자리가 더하면 2바퀴까지 차지하는 자리의 수이다.
    for i in range(0,m//2+1): #따라서 order에 1바퀴 돌렸을때 값을 더하고, 티켓팅한 순서n이 이 1바퀴 안의 범위(order값)보다 작으면 1,1 부터 부터 1바퀴를 돌다보면 순서n의 좌석이 나온다
        #n번의 좌석 위치가 나온다. 만얀 n번이 1바퀴 돌린 order값보다 크면 order값이 2바퀴 돌았을 때의 값일때와 비교하여 몇번째 바퀴를 돌았을때의 좌석인지 구한다.
        order+=(x+y-4*i)*2-4 #바퀴수마다 1바퀴도는데 필요한 수가 점점 줄어든다. 따라서 n이 속한 바퀴수가 나올 때 까지 돌아준다.
        
        if n <=order: #만약 n이 (i+1)번째 바퀴수 돌았을때 필요한 좌석수 보다 작으면 그때의 n번 좌석의 위치를 구한다.
            x1,y1=i+1,i #x1,y1의 초기값은 i+1,i이다. (좌표상에서 0바퀴 돌면 1,1에서 시작, 1바퀴 돌면 2,2에서 시작한다.)
            #이때 처음 값은 y축으로 올라가는 값이기 때문에 x1,y1값은 (1,0) (2,1) 과 같이 계산하기 쉽게 만들었다. 0번좌석이 (1,0)이라하면 1번좌석은 (1,1) 과같음.
            
            n-=order-((x+y-4*i)*2-4) #x1,y1이 k번째 바퀴값 보다 작으면 k-1번째 바퀴의 시작지점부터 x1,y1값의 위치를 탐색한다.(n값은 i+1번째 바퀴값을 빼서 나머지값 을 움직이는 데 활용한다.)

            if n<=y-2*i:#n이 처음 y축 위로 올라가는 방향위에 있을때
                y1=i+n#x값은 그대로이고 y만 움직이기 때문에 y좌표에서 n방큼 더해주면 된다.

            elif n<=(y-2*i+x-2*i-1): #n이 y축 위로 올라간 후 x축 방향에서 움직일때
                x1+=n-y+2*i #(i+1)번째 바퀴에서 n번째 좌석이다. 따라서 x1값에서 올라간 y값만큼 빼주면 된다.
                y1=y-i#y는 다 올라가고 x만 움직이기 때문에 y값은 (i+1)번째 바퀴이기 때문에 y-i값을 가진다.

            elif n<=(y-2*i+x-2*i-1+y-2*i-1): #n이 다시 y축 방향으로 내려오는 위치에 있을때
                x1=x-i
                y1=y-i-(n-(y-2*i+x-2*i-1))

            else:#n이 마지막으로 x축방향으로 -방향으로 다시 움직일때 좌표
                x1=x-i-(n-(y-2*i+x-2*i-1+y-2*i-1))
                y1=i+1
            return print(x1,y1)
check(n,x,y)

        



