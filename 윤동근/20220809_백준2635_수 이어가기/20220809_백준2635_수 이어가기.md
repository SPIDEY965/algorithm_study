# 수 이어가기

| 시간 제한 | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ---- | ---- | ----- | ------- |
| 1 초   | 128 MB | 7583 | 2958 | 2324  | 37.018% |

## 문제

다음과 같은 규칙에 따라 수들을 만들려고 한다.

1. 첫 번째 수로 양의 정수가 주어진다.
2. 두 번째 수는 양의 정수 중에서 하나를 선택한다.
3. 세 번째부터 이후에 나오는 모든 수는 앞의 앞의 수에서 앞의 수를 빼서 만든다. 예를 들어, 세 번째 수는 첫 번째 수에서 두 번째 수를 뺀 것이고, 네 번째 수는 두 번째 수에서 세 번째 수를 뺀 것이다.
4. 음의 정수가 만들어지면, 이 음의 정수를 버리고 더 이상 수를 만들지 않는다.

첫 번째 수로 100이 주어질 때, 두 번째 수로 60을 선택하여 위의 규칙으로 수들을 만들면 7개의 수들 100, 60, 40, 20, 20 , 0, 20이 만들어진다. 그리고 두 번째 수로 62를 선택하여 위의 규칙으로 수들을 만들면 8개의 수들 100, 62, 38, 24, 14, 10, 4, 6이 만들어진다. 위의 예에서 알 수 있듯이, 첫 번째 수가 같더라도 두 번째 수에 따라서 만들어지는 수들의 개수가 다를 수 있다.

입력으로 첫 번째 수가 주어질 때, 이 수에서 시작하여 위의 규칙으로 만들어지는 최대 개수의 수들을 구하는 프로그램을 작성하시오. 최대 개수의 수들이 여러 개일 때, 그중 하나의 수들만 출력하면 된다.

## 입력

첫 번째 수가 주어진다. 이 수는 30,000 보다 같거나 작은 양의 정수이다.

## 출력

첫 번째 줄에는 입력된 첫 번째 수로 시작하여 위의 규칙에 따라 만들 수 있는 수들의 최대 개수를 출력한다.

둘째 줄에 그 최대 개수의 수들을 차례대로 출력한다. 이들 수 사이에는 빈칸을 하나씩 둔다.

## 예제 입력 1

100

## 예제 출력 1

8
100 62 38 24 14 10 4 6

## 나의 코드

```python
def a(F):#숫자 N에 대하여 그다음 임의의 수 X1(X는 0이상 N이하)에 대하여 N-X1=X2이고 그다음 X1-X2=X3로 계속 수가 이어진다.
         #그러나 X의 값이 음수가 되면 멈추게 된다. 그래서 숫자 N에 대해서 가장 많이 이어지는 값 max와 그 떄의 음수가 아닌 리스트 maxlist를 반환하는 함수.
    max=0
    if F==1:#들어온 수가 1이면 4를 반환한다. 이때는 예외적이라서 1가지 경우만 넣었다.
        return 4, [1, 1, 0, 1]

    for i in range(F//2,F): #F의 절반보다 작은 수를 다음수에 넣으면 바로 음수가 나오게 된다. 따라서 최대한 범위를 줄여준다.(간단하게 수학적 계산)
        NL=[F]
        NL.append(i)#N의 다음수로 i를 넣어주는데 i는 N의 절반 부터 시작한다.
        while NL[-1]>=0:
            NL.append(NL[-2]-NL[-1])#N과 i를 시작으로 계속 이어나가고, NL리스트의 마지막이 음수가 되면 끝나게 된다.
        cnt=len(NL)-1#마지막 음수는 제거한 갯수이기 때문에 1을 뺀다.

        if max<cnt:
            max=cnt
            maxlist=NL[:-1]#가장 많이 이은 x값과 그 리스트를 넣어준다.

    return max, maxlist

N=int(input())
c,d=a(N)
print(c)
print(*d)
```

![](20220809_백준2635_수%20이어가기assets/2022-08-09-13-52-52-image.png)

우선 처음풀때 범위를 좁혀줬다. 왜냐하면 절반 이하로 다음수가 나오면 음수가 나오는 것은

당연하기 때문이다. 그렇기 때문에 수학적으로 봤을때, 수가 많이 이어지려먼 60~70% 사이라고 생각한다. 하지만 확실하지 않기 때문에 50% 이상의 범위로 좁혀줬다.  그리고 생각보다는 어렵운 알고리즘은 아니였고, 여기서 중요한 것은 범위를 얼마나 잘 좁히느냐 라고 생각한다. 

## 다른 사람의 코드(가장 시간 짧은코드)

```python
import math #math 모듈을 사용하였따.
N=int(input())
if N==1:
    print('4\n1 1 0 1')
elif N==2:
    print('5\n2 1 1 0 1')
elif N==3:
    print('6\n3 2 1 1 0 1')
elif N==4:
    print('5\n4 2 2 0 1')
elif N==5:
    print('7\n5 3 2 1 1 0 1')#N은1~5까지는 예외로 뒀다.(수가 작아서 수학적 힘듬)
else:
    a=math.floor(N*(5**0.5-1)/2)#주어진 숫자보다 작거나 같은 수중 가장 큰 것 반환.
    c1=[N, a]#수학적으로 (루트5-1)/2를 곱한값 근처에서 가장 많이 나온다. 
    while c1[-2]>=c1[-1]:
        c1.append(c1[-2]-c1[-1])#이쪽은 나의 방법과 거의 유사하다.
    c2=[N, a+1]
    while c2[-2]>=c2[-1]:
        c2.append(c2[-2]-c2[-1])#뒤에서 2번째수가 뒤에서 1번째 수보다 크거나 같으면 계속 수행.
#나는 뺏을때 음수가 나오는 것을 기준으로 했는데 이렇게 두 수의 비교로 하면 len값에서 1을
#안빼도 돼기 때문에 더 좋은 것 같다. 
    if len(c1)>len(c2):
        print(len(c1))
        print(' '.join(map(str, c1)))
    else:
        print(len(c2))
        print(' '.join(map(str, c2)))
```

매우 수학적으로 접근하여서 시간을 줄였기 때문에 사실 의미가 큰거 같지는 않다. 왜냐하면 저 수를 곱한 값이 가장 경우의 수가 많다는 것을 알기가 힘들기 때문이다. 직관적으로도 한계가 있다고 생각한다.

## 다른 사람의 코드(가장 길이 짧은코드)

```python
n=int(input())
l=0
s=0
for j in range(1,n+1):
 t=j;c=0;i=n
 while i>=0:c+=1;i,j=j,i-j#리스트를 쓰지않고 i=n이고 다음에 나오는 수 j라 할때
 if c>l:s=t;l=c#마지막 2개의 수는 항상 는 j, i-j가 나온다. 이를 i>=0일떄 계속 시행.
print(l)#c는 count갯수이다. l은 c의 갯수를 저장하는데 큰것만 저장한다.t는 그때 사용한 j값이다.
while n>=0:print(n);n,s=s,n-s
```

수식을 최대한 줄여서 표현하였는데 그 방식은 거의 비슷하다. 그리고 list를 안썻단느 것은 배워야 할 스킬인 것같다. 그리고 print(n)을 하는 방식도 신기해서 배워야 한다. 


