# 1로 만들기 성공

| 시간 제한                                                   | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |
| ------------------------------------------------------- | ------ | ------ | ----- | ----- | ------- |
| 0.15 초 ([하단 참고](https://www.acmicpc.net/problem/1463#)) | 128 MB | 215135 | 70411 | 45061 | 32.198% |

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

## 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

![](20220829_백준1463_1로%20만들기assets/2022-08-29-21-12-22-image.png)

## 나의 코드

```python
N = int(input())
dp = [N] * (N+1)
dp[-1] = 0
for i in range(N,0,-1):
    if i%3 == 0:                            # 맨 끝(N)에서 부터 3나눌때 그 값까지 더 적은 과정 저장.
        dp[i//3] = min(dp[i]+1, dp[i//3])
    if i%2 == 0:
        dp[i//2] = min(dp[i]+1, dp[i//2])
    dp[i-1] = min(dp[i]+1, dp[i-1])
print(dp[1])
```

![](20220829_백준1463_1로%20만들기assets/2022-08-29-21-12-44-image.png)

dp라고 생각하고 풀었는데 사실 거의 다 돌아본거 같다. 그래서인지 964ms가 걸렸다. 그리고 무엇보다 오늘 코딩테스트를 봤기 때문에 머리가 멍해서 잘 풀리지가 않았다. 그래서 너무 푸는데 너무 오래걸렸고 너무 피곤했다. 아직도 DP는 몸에 안익는 거 같고 너무 어려운 거 같다.

## 다른 사람 코드(빠른 코드)

```python
s={1:0,2:1}
def f(n):
 if n in s:return s[n] # 1또는 2이면 0과 1 출력
 m=1+min(f(n//2)+n%2,f(n//3)+n%3) # n값이 1또는 2가 될때까지 내려간다. 그리고 2또는 3으로 계속 나누게 나머지 값 만큼 더해진다.
 s[n]=m
 return m
print(f(int(input())))
```

![](20220829_백준1463_1로%20만들기assets/2022-08-29-21-14-26-image.png)

이 코드는 딕셔너리와 재귀함수를 썼다. 1또는 2일 경우에는 바로 출력 되게 만들었고, 그 외에는 재귀함수에 계속 돌다가 n값이 1또는 2가 나오면 return하게 된다. 왜 이런생각을 못했을까 아쉬웠다. 알고나면 쉬운데 모르면 너무 어려운 것 같다.

## 다른 사람 코드(짧은 코드)

```python
f=lambda n:n<2or min(n%3+f(n//3),n%2+f(n//2))+1
print(f(int(input()))-1)
```

![](20220829_백준1463_1로%20만들기assets/2022-08-29-21-15-07-image.png)

이 것도 위의 코드와 마찬가지이다. 대신 f에 함수를 넣어 재귀로 돌게 만들었다. 오늘은 코딩테스트로 너무 피곤해서 집중력이 떨어져서 분석하기가 많이 힘든 하루였따.
