1767. [SW Test 샘플문제] 프로세서 연결하기]
- 시간 : 50개 테스트케이스를 합쳐서 *C++의 경우 2초* / *Java의 경우 4초* / *Python의 경우 8초*

- 메모리 : 힙, 정적 메모리 합쳐서 *256MB* 이내, 스택 메모리 *1MB* 이내

※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.  

삼성에서 개발한 최신 모바일 프로세서 멕시노스는 가로 N개 x 세로 N개의 cell로 구성되어 있다.  

  ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-03-27-image.png)

1개의 cell에는 1개의 Core 혹은 1개의 전선이 올 수 있다.  
  ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-03-42-image.png)

멕시노스의 가장 자리에는 전원이 흐르고 있다.  
  ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-03-53-image.png)
Core와 전원을 연결하는 전선은 직선으로만 설치가 가능하며,  
 ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-04-05-image.png)

전선은 절대로 교차해서는 안 된다.  
  ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-04-17-image.png)
초기 상태로는 아래와 같이 전선을 연결하기 전 상태의 멕시노스 정보가 주어진다.  

(멕시노스의 가장자리에 위치한 Core는 이미 전원이 연결된 것으로 간주한다.)  

  ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-04-26-image.png)

  ![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-04-35-image.png)

**<u>▶ 최대한 많은 Core에 전원을 연결하였을 경우, 전선 길이의 합을 구하고자 한다.<br><br>&nbsp;&nbsp; 단, 여러 방법이 있을 경우, 전선 길이의 합이 최소가 되는 값을 구하라.</u>**  

위 예제의 정답은 12가 된다.  

**[제약 사항]**  

1. 7 ≤  N ≤ 12  

2. Core의 개수는 최소 1개 이상 12개 이하이다.  

3. 최대한 많은 Core에 전원을 연결해도, 전원이 연결되지 않는 Core가 존재할 수 있다.  

**[입력]**  

입력의 가장 첫 줄에는 총 테스트 케이스의 개수 T가 주어지며 그 다음 줄부터 각 테스트 케이스가 주어진다.  

각 테스트 케이스의 첫 줄에는 N값이 주어지며, 다음 N줄에 걸쳐서 멕시노스의 초기 상태가 N x N 배열로 주어진다.  

0은 빈 cell을 의미하며, 1은 core를 의미하고, 그 외의 숫자는 주어지지 않는다.  

**[출력]**  

각 테스트 케이스마다 '#X'를 찍고, 한 칸 띄고, 정답을 출력한다.  

(X는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)

![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-04-49-image.png)

## 나의 코드

```python
def go(Q):                      # Q 가 코어개수만큼 돼면 멈춘다.
    global cnt1, cnt2, core, line
    if Q == len(C):
        if cnt1 > core:
            core = cnt1
            line = cnt2
        elif cnt1 == core:
            if line > cnt2:
                line = cnt2     # 가장 많이 연결했을때 찾기.
        return
    y, x = C[Q][0], C[Q][1]     # y,x 의 좌표는 Q의 값에따라 순차적으로 1번코어~ len(C)번 코어

    for j in range(y):
        if M[j][x] != 0:        # 1가지 방향에 대해 연결 가능한지 탐색
            break
    else:
        cnt1 += 1               # 만약 연결 가능하면 코어 연결갯수 +1
        for k in range(y):
            cnt2 += 1           # 전선필요 갯수 +1
            M[k][x] = 1
        go(Q+1)
        cnt1 -= 1
        for k in range(y):
            cnt2 -= 1
            M[k][x] = 0

    for j in range(x + 1, N):   # 오른쪽 방향
        if M[y][j] != 0:
            break
    else:
        cnt1 += 1
        for k in range(x + 1, N):
            cnt2 += 1
            M[y][k] = 1
        go(Q + 1)
        cnt1 -= 1
        for k in range(x + 1, N):
            cnt2 -= 1
            M[y][k] = 0

    for j in range(y + 1, N):   # 아래 방향
        if M[j][x] != 0:
            break
    else:
        cnt1 += 1
        for k in range(y + 1, N):
            cnt2 += 1
            M[k][x] = 1
        go(Q+1)
        cnt1 -= 1
        for k in range(y + 1, N):
            cnt2 -= 1
            M[k][x] = 0

    for j in range(x):           # 왼쪽 방향
        if M[y][j] != 0:
            break
    else:
        cnt1 += 1
        for k in range(x):
            cnt2 += 1
            M[y][k] = 1
        go(Q+1)
        cnt1 -= 1
        for k in range(x):
            cnt2 -= 1
            M[y][k] = 0
    go(Q+1)                       # Q번 코어 연결 안하고 Q+1번쨰 코어 탐색할 때

T = int(input())
for _ in range(1, T+1):
    C = []                                      # 연결해야하는 코어 좌표 담기.
    M = []                                      # 전체 맵 담기
    N = int(input())
    for i in range(N):
        temp = list(map(int, input().split()))  # temp에 1줄씩 반도체판 맵 가져오기
        if i != 0 and i != N-1:
            for j in range(1, N-1):             # 모서리쪽에 없으면 코어 좌표 C에 추가.
                if temp[j] == 1:
                    C.append((i, j))
        M.append(temp)                          # C에 temp 1줄씩 담기.
    core = 0
    line = 2000
    cnt1 = 0
    cnt2 = 0
    go(0)
    print(f'#{_} {line}')


```

![](20220904_SWEA1767_프로세서%20연결하기assets/2022-09-04-21-05-30-image.png)

처음에는 조합을 사용하여 완전탐색을 시도했었는데 메모리가 초과했었다. 그래서 방법을 바꾼것이 기존 작업을 쭉 이어나가서 기존 전선 지도를 그대로 사용하였다. 조합을 사용하면 만약 연결해야할 코어 갯수가 5개라면 그 코어를 연결안했을때, 위, 오른쪽, 아래, 왼쪽 을 다 탐색해 봐야해서 5가지이고 5의 5제곱개 만큼 완전 탐색해야 하지만, DFS의 방법을 사용하면 만약 1번 코어를 위로 연결했을때 2번 코어를 위로 연결하려했지만 불가하면 오른쪽으로 연결하고 이런식으로 쭉 가면 된다. 그러면 불필요한 조합을 하지않고 넘어갈 수 있기 때문에 시간이 단축된다. 이 문제는 다른 사람 코드를 보고싶지만, 못보게 만들었다. 그래서 나의 코드밖에 못올린다. python 으로 가장 빠른사람은 174ms 이다 나의 코드보다 3~4배 사이로 빠르다. 어떻게 줄일지 다시한번 생각해 봐야할 거 같다.


