# 파이프 옮기기 1

| 시간 제한          | 메모리 제한 | 제출    | 정답    | 맞힌 사람 | 정답 비율   |
| -------------- | ------ | ----- | ----- | ----- | ------- |
| 1 초 (추가 시간 없음) | 512 MB | 22705 | 10720 | 7369  | 46.740% |

## 문제

유현이가 새 집으로 이사했다. 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 (r, c)로 나타낼 수 있다. 여기서 r은 행의 번호, c는 열의 번호이고, 행과 열의 번호는 1부터 시작한다. 각각의 칸은 빈 칸이거나 벽이다.

오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 아래와 같은 형태이고, 2개의 연속된 칸을 차지하는 크기이다.

![](https://upload.acmicpc.net/3ceac594-87df-487d-9152-c532f7136e1e/-/preview/)

파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능하다.

![](https://upload.acmicpc.net/b29efafa-dbae-4522-809c-76d5c184a231/-/preview/)

파이프는 매우 무겁기 때문에, 유현이는 파이프를 밀어서 이동시키려고 한다. 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다. 즉, 파이프는 항상 빈 칸만 차지해야 한다.

파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다. 파이프는 밀면서 회전시킬 수 있다. 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.

파이프가 가로로 놓여진 경우에 가능한 이동 방법은 총 2가지, 세로로 놓여진 경우에는 2가지, 대각선 방향으로 놓여진 경우에는 3가지가 있다.

아래 그림은 파이프가 놓여진 방향에 따라서 이동할 수 있는 방법을 모두 나타낸 것이고, 꼭 빈 칸이어야 하는 곳은 색으로 표시되어져 있다.

![](https://upload.acmicpc.net/0f445b26-4e5b-4169-8a1a-89c9e115907e/-/preview/)

가로

![](https://upload.acmicpc.net/045d071f-0ea2-4ab5-a8db-61c215e7e7b7/-/preview/)

세로

![](https://upload.acmicpc.net/ace5e982-6a52-4982-b51d-6c33c6b742bf/-/preview/)

대각선

가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.

## 입력

첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다. 둘째 줄부터 N개의 줄에는 집의 상태가 주어진다. 빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.

## 출력

첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다. 이동시킬 수 없는 경우에는 0을 출력한다. 방법의 수는 항상 1,000,000보다 작거나 같다.

## 나의 코드(DP로 다시 제작해본 코드)

```python
N = int(input())                                              # NxN 행렬
house = [list(map(int, input().split())) for i in range(N)]   # 행렬 받아오기
DP = [[[0, 0, 0] for i in range(N)] for j in range(N)]        # DP i,j에 올수 있는 관 종류의 수량
DP[0][1][2] = 1
for i in range(N):
    for j in range(2, N):
        if house[i][j] == 0:
            if i < 1:                           # 가장 윗열은 왼쪽에서 오른쪽으로 가는 관만 받기 가능 
                DP[i][j][2] += DP[i][j-1][2]
            else:
                if house[i][j-1] == 0 and house[i-1][j] == 0:   # 아랫 열은 위, 왼쪽, 대각선 성분에 따라 관 받을수 있는 것 다름.
                    DP[i][j][1] += DP[i - 1][j - 1][1] + DP[i-1][j - 1][2] + DP[i - 1][j-1][0]
                DP[i][j][0] += DP[i-1][j][0] + DP[i-1][j][1]
                DP[i][j][2] += DP[i][j-1][2] + DP[i][j-1][1]
print(sum(DP[N-1][N-1])) 
```

![](20220822_백준17070_파이프%20옮기기%201assets/2022-08-23-22-26-38-image.png)

## 예전 코드

```python
def go(y=0, x=1, case=1):
    global cnt
    if y == x == N-1:
        cnt += 1
        return
    
    if case == 1:
        if house[y][x+1] == 0:
            go(y, x+1, 1)
            if house[y+1][x] == 0 and house[y+1][x+1] == 0:
                go(y + 1, x + 1, 3)
    
    elif case == 2:
        if house[y+1][x] == 0:
            go(y+1, x, 2)
            if house[y][x+1] == 0 and house[y+1][x+1] == 0:
                go(y + 1, x + 1, 3)
                
    else:
        if house[y][x+1] == 0:
            go(y, x+1, 1)
            if house[y+1][x] == 0 and house[y+1][x+1] == 0:
                go(y + 1, x + 1, 3)
        if house[y+1][x] == 0:
            go(y + 1, x, 2)

N = int(input())
house = [list(map(int, input().split()))+[1] for i in range(N)]
house.append([1]*(N+1))
cnt = 0
go(0, 1, 1)
print(cnt)
```

![](20220822_백준17070_파이프%20옮기기%201assets/2022-08-23-22-26-54-image.png)

그 전에는 pypy로 겨우겨우 시간을 넘겼다.  pypy는 될 수 있는 모든 경로로 pipe를 이동시키기 때문에 엄청난 양의 계산을 요구했다. 하지만 DP를 쓰니 기존 데이터에서 계속 더하기만 하면 되기 때문에 엄청 빨라졌다. 아직도 DP가 미숙해서 더 열심히 공부해야겠다. 부족함을 느끼고 있고.. 정말 분발해야겠다. 오늘도 화이팅이다.
