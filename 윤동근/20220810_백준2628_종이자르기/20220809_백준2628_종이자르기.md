# 종이자르기

| 시간 제한 | 메모리 제한 | 제출   | 정답   | 맞힌 사람 | 정답 비율   |
| ----- | ------ | ---- | ---- | ----- | ------- |
| 1 초   | 128 MB | 5997 | 3349 | 2753  | 57.570% |

## 문제

아래 <그림 1>과 같이 직사각형 모양의 종이가 있다. 이 종이는 가로방향과 세로 방향으로 1㎝마다 점선이 그어져 있다. 가로 점선은 위에서 아래로 1번부터 차례로 번호가 붙어 있고, 세로 점선은 왼쪽에서 오른쪽으로 번호가 붙어 있다.

![](https://upload.acmicpc.net/1e689dae-2d24-463b-8725-fb58ae8cd2ba/-/preview/)

<그림 1>

점선을 따라 이 종이를 칼로 자르려고 한다. 가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다. 예를 들어, <그림 1>의 가로 길이 10㎝이고 세로 길이 8㎝인 종이를 3번 가로 점선, 4번 세로 점선, 그리고 2번 가로 점선을 따라 자르면 <그림 2>와 같이 여러 개의 종이 조각으로 나뉘게 된다. 이때 가장 큰 종이 조각의 넓이는 30㎠이다.

![](https://upload.acmicpc.net/cf033b95-91ef-4e71-8f2c-49c653e27622/-/preview/)

<그림 2>

입력으로 종이의 가로 세로 길이, 그리고 잘라야할 점선들이 주어질 때, 가장 큰 종이 조각의 넓이가 몇 ㎠인지를 구하는 프로그램을 작성하시오.

## 입력

첫줄에는 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 둘째 줄에는 칼로 잘라야하는 점선의 개수가 주어진다. 셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다. 가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 입력되는 두 숫자 사이에는 빈 칸이 하나씩 있다.

## 출력

첫째 줄에 가장 큰 종이 조각의 넓이를 출력한다. 단, 넓이의 단위는 출력하지 않는다.

## 예제 입력 1 복사

10 8
3
0 3
1 4
0 2

## 예제 출력 1 복사

30

## 나의 코드

```python
X,Y=list(map(int,input().split())) # X,Y칸
N=int(input()) # 자르는 횟수
x_arr=[0,X] # 나중에 자른 구간들을 구하기 위해 종이 맨 끝도 좌표로 넣어준다 [0,X]
y_arr=[0,Y] # [0,y]도 종이 맨끝이니 넣어준다.
for i in range(N): # 자르는 구간들을 입력하고 저장한다.
    cut=input().split()
    if cut[0]=='0': # cut[0]이 0이면 가로축, 1이면 세로축 자르기
        y_arr.append(int(cut[1]))
    else:
        x_arr.append(int(cut[1]))
x_arr.sort() # x축 자르는 위치 정리
x_span=[] # 자른 후 길이들 리스트
y_arr.sort() # y축 자르는 위치 정리
y_span=[] # 자른 후 길이들 리스트
for i in range(len(x_arr)-1):
    x_span.append(x_arr[i+1]-x_arr[i]) # 0~X 사이 자른 길이 저장.
for i in range(len(y_arr)-1):
    y_span.append(y_arr[i+1]-y_arr[i]) # 0~Y 사이 자른 길이 저장.
print(max(x_span)*max(y_span)) # X 가장 긴 길이 * Y 가장 긴 길이 = 가장 큰 넓이
```

이전에 백준_2669번_직사각형 네개의 합집합에서 잘한 사람의 코드를 봤을 때 사용했던 방법이 떠올라서 그방법을 적용했습니다. 확실히 다른사람을 보며 배웠던 것을 사용할 수 있어서 좋았습니다. 

## 다른 사람의 코드(빠른 코드)

```python
w,h=map(int,input().split()) # 너, 높이
a,b=[0,h],[0,w] # 맨끝좌표 삽입
for _ in range(int(input())):
  f,x=map(int,input().split()) # 더 간단한 방법. f,x로 받기.
  if f: b.append(x) #만약 f면 b리스트에 삽입 (w관련)
  else: a.append(x) #아니면 a리스트 삽입 (h관련)
a.sort(); b.sort() #크기순 정렬
m,n=0,0
for i in range(len(a)-1): #최대값 찾기
  if m<a[i+1]-a[i]:
    m=a[i+1]-a[i]
for j in range(len(b)-1):
  if n<b[j+1]-b[j]:
    n=b[j+1]-b[j] 
print(m*n) #최대값 출력
```

저와 거의 같은 방법이고, list없이 최대값 찾았다는 점에서 달랐습니다. 그리고 x,y를 자르는 축을 정하는 것이 더 간단했습니다. 전반적으로 다 같았기 때문에, max, min값을 찾을 때는 list없이 찾는 것이 더 좋겠다고 생각했습니다.

## 다른 사람의 코드(짧은 코드)

```python
f=lambda:map(int,input().split()) #거의 함수와 가깝게 쓰인다.
w,h=f();w,h=[0,w],[0,h] #맨끝좌표 삽입
for i in range(*f()):o,t=f();[h,w][o]+=[t] #o는 축을, t는 자르는 위에 자르는 위치 받
w.sort();h.sort() #[h,w][o]는 o가 0이면 h에 1이면 w에 t가 추가된다.
print(max((w-v)*(y-x)for v,w in zip(w,w[1:])for x,y in zip(h,h[1:])))
```

일단 [h,w][숫자] += [변수] 로 숫자에 따라 원하는 변수에 다른 변수를 추가할 수 있다는 것이 좋아다. 그리고 마지막에 max값을 구하는데 zip함수를 2번써서 모든 경우에 대해 짧게 구한것이 배울점이였다. 오늘도 알차게 배운 것 같고 코딩 고수들을 모방하며 더 성장해 혼자서도 창조할 수 있는 사람이 돼야겠다.
